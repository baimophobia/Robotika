# -*- coding: utf-8 -*-
"""Nur Ihsan Ibrahim Abdul Fattah_Week 11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NK5Q6py7l1SIXc89WIgVaVKpLKXBhqym
"""

from google.colab import files
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Unggah gambar
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load gambar
image = cv2.imread(filename, cv2.IMREAD_GRAYSCALE)

# Deteksi tepi menggunakan Canny
edges = cv2.Canny(image, 50, 150)

# Deteksi garis menggunakan Hough Transform
lines = cv2.HoughLines(edges, 1, np.pi/180, 100)

# Gambar garis pada gambar asli
output = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
if lines is not None:
    for line in lines:
        rho, theta = line[0]
        a, b = np.cos(theta), np.sin(theta)
        x0, y0 = a * rho, b * rho
        x1, y1 = int(x0 + 1000 * (-b)), int(y0 + 1000 * a)
        x2, y2 = int(x0 - 1000 * (-b)), int(y0 - 1000 * a)
        cv2.line(output, (x1, y1), (x2, y2), (0, 255, 0), 2)

# Tampilkan hasil
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1), plt.imshow(image, cmap='gray'), plt.title("Original Image")
plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB)), plt.title("Detected Lines")
plt.show()

"""Hasil Analisis

Kode ini digunakan untuk mendeteksi garis pada sebuah gambar. Pertama, gambar diunggah dan diubah menjadi grayscale agar lebih mudah diproses. Kemudian, algoritma Canny digunakan untuk mendeteksi tepi gambar dengan mencari perubahan intensitas piksel yang tajam. Setelah itu, metode Hough Transform diaplikasikan untuk mendeteksi garis berdasarkan parameter rho dan theta dalam koordinat polar. Garis yang terdeteksi kemudian digambar ulang pada gambar asli dengan warna hijau. Hasil akhirnya menampilkan dua gambar: gambar asli dan gambar dengan garis yang telah terdeteksi. Proses ini berguna untuk berbagai aplikasi seperti navigasi robot atau analisis gambar, meskipun akurasi deteksi sangat bergantung pada pengaturan parameter yang digunakan.
"""

from google.colab import files
import cv2
import matplotlib.pyplot as plt

# Fungsi untuk memeriksa apakah template lebih kecil dari gambar utama
def validate_template_size(main_image, template):
    if template.shape[0] > main_image.shape[0] or template.shape[1] > main_image.shape[1]:
        raise ValueError("Template size must be smaller than the main image size!")

try:
    # Unggah gambar utama
    print("Upload main image:")
    main_image_file = files.upload()
    main_image_filename = list(main_image_file.keys())[0]

    # Unggah template
    print("Upload template image:")
    template_file = files.upload()
    template_filename = list(template_file.keys())[0]

    # Load gambar utama dan template
    main_image = cv2.imread(main_image_filename)  # Gambar berwarna
    template = cv2.imread(template_filename, cv2.IMREAD_GRAYSCALE)  # Template tetap grayscale

    # Validasi ukuran template
    validate_template_size(main_image, template)

    # Konversi gambar utama ke grayscale untuk template matching
    main_image_gray = cv2.cvtColor(main_image, cv2.COLOR_BGR2GRAY)

    # Lakukan Template Matching
    result = cv2.matchTemplate(main_image_gray, template, cv2.TM_CCOEFF_NORMED)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

    # Gambar kotak di sekitar area yang terdeteksi
    h, w = template.shape
    top_left = max_loc
    bottom_right = (top_left[0] + w, top_left[1] + h)

    # Salin gambar untuk output dan tambahkan kotak dan label
    output = main_image.copy()
    cv2.rectangle(output, top_left, bottom_right, (0, 255, 0), 2)  # Kotak hijau
    # Tambahkan kotak label di atas kotak deteksi
    label_top_left = (top_left[0], top_left[1] - 30)
    label_bottom_right = (top_left[0] + 100, top_left[1])
    cv2.rectangle(output, label_top_left, label_bottom_right, (0, 255, 0), -1)  # Kotak hijau solid untuk label
    cv2.putText(output, "Vas Bunga", (top_left[0] + 5, top_left[1] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)  # Teks putih di atas kotak label

    # Tampilkan hasil
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1), plt.imshow(cv2.cvtColor(main_image, cv2.COLOR_BGR2RGB)), plt.title("Main Image")
    plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB)), plt.title("Detected Area with Label")
    plt.show()

except ValueError as ve:
    print("Error:", ve)
except Exception as e:
    print("An unexpected error occurred:", e)

"""Hasil Analisis

Kode ini digunakan untuk mendeteksi objek dalam gambar menggunakan metode template matching. Proses dimulai dengan mengunggah gambar utama dan template yang ingin dicari dalam gambar utama. Sebelum melakukan pencocokan, dilakukan validasi untuk memastikan bahwa ukuran template lebih kecil dari gambar utama. Selanjutnya, gambar utama dikonversi ke format grayscale agar cocok dengan template yang juga dalam format grayscale. Dengan menggunakan fungsi cv2.matchTemplate, lokasi terbaik dari template dalam gambar utama dicari berdasarkan nilai korelasi yang dinormalisasi. Lokasi dengan nilai korelasi tertinggi kemudian digunakan untuk menggambar kotak hijau di sekitar area yang terdeteksi, lengkap dengan label "Vas Bunga" di atasnya untuk memberi identifikasi pada objek. Hasil akhirnya ditampilkan dalam dua gambar: satu menunjukkan gambar utama dan satu lagi menampilkan area yang berhasil dideteksi. Pendekatan ini sangat efektif untuk mengenali pola dalam gambar, namun keakuratannya bergantung pada kesesuaian ukuran dan kemiripan template dengan objek dalam gambar utama.
"""

from google.colab import files
import cv2
import matplotlib.pyplot as plt

# Unggah gambar
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load gambar
image = cv2.imread(filename)

# Buat Gaussian Pyramid
pyramid = [image]
for i in range(3):  # Buat 3 level pyramid
    image = cv2.pyrDown(image)
    pyramid.append(image)

# Tampilkan setiap level
plt.figure(figsize=(15, 5))
for level, img in enumerate(pyramid):
    plt.subplot(1, len(pyramid), level + 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f'Level {level}')
    plt.axis('off')

plt.show()

"""Hasil Analisis

Kode ini digunakan untuk membuat dan menampilkan Gaussian Pyramid dari sebuah gambar. Gaussian Pyramid adalah teknik dalam pemrosesan citra yang bertujuan untuk menghasilkan versi gambar dengan resolusi lebih rendah secara bertahap. Proses dimulai dengan mengunggah gambar menggunakan Google Colab, kemudian gambar tersebut dimuat menggunakan OpenCV. Selanjutnya, pyramid dibuat dengan metode cv2.pyrDown, yang secara bertahap mengurangi ukuran gambar dengan menghaluskannya menggunakan filter Gaussian sebelum melakukan subsampling. Dalam kode ini, tiga level pyramid dihasilkan, di mana gambar pada setiap level memiliki resolusi yang lebih kecil dari level sebelumnya. Gambar-gambar pada setiap level pyramid disimpan dalam sebuah daftar dan ditampilkan menggunakan Matplotlib. Hasil akhirnya adalah visualisasi gambar pada setiap level, mulai dari resolusi asli hingga resolusi yang semakin rendah. Teknik ini berguna dalam berbagai aplikasi, seperti deteksi objek, analisis skala multi-resolusi, atau kompresi gambar, karena memungkinkan analisis gambar pada berbagai tingkat detail.
"""

from google.colab import files
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Unggah gambar
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load gambar
image = cv2.imread(filename, cv2.IMREAD_COLOR)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Deteksi lingkaran menggunakan Hough Transform
circles = cv2.HoughCircles(
    gray,
    cv2.HOUGH_GRADIENT,
    dp=1.2,
    minDist=50,  # Pastikan jarak antar lingkaran lebih besar
    param1=100,  # Threshold untuk Canny edge detection
    param2=50,   # Sensitivitas deteksi (naikkan jika terlalu banyak deteksi)
    minRadius=50,  # Ukuran radius minimal bola
    maxRadius=150  # Ukuran radius maksimal bola
)

# Gambar lingkaran yang terdeteksi pada gambar asli
output = image.copy()
if circles is not None:
    circles = np.uint16(np.around(circles))
    for circle in circles[0, :]:
        center = (circle[0], circle[1])  # Koordinat pusat lingkaran
        radius = circle[2]  # Radius lingkaran
        cv2.circle(output, center, radius, (0, 255, 0), 2)  # Gambar lingkaran
        cv2.circle(output, center, 2, (0, 0, 255), 3)  # Gambar pusat lingkaran

# Tampilkan hasil
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1), plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)), plt.title("Original Image")
plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB)), plt.title("Detected Circles")
plt.show()

"""Hasil Analisis

Kode ini digunakan untuk mendeteksi lingkaran dalam gambar menggunakan metode Hough Transform. Gambar diunggah, dikonversi ke grayscale, dan dideteksi lingkarannya menggunakan cv2.HoughCircles dengan parameter tertentu, seperti jarak antar lingkaran, radius minimal dan maksimal, serta sensitivitas deteksi. Jika lingkaran ditemukan, gambar asli ditandai dengan lingkaran hijau dan titik pusat merah menggunakan cv2.circle. Hasilnya ditampilkan dalam dua panel: gambar asli dan gambar dengan lingkaran terdeteksi. Teknik ini berguna untuk identifikasi objek berbentuk lingkaran dalam berbagai aplikasi.
"""

from google.colab import files
import cv2
import matplotlib.pyplot as plt
import numpy as np
from sklearn.cluster import KMeans

# Unggah gambar
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load gambar
image = cv2.imread(filename)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Konversi ke format RGB
reshaped_image = image.reshape((-1, 3))  # Ubah menjadi array 2D (pixel x warna)

# K-Means Clustering untuk menemukan warna dominan
k = 5  # Jumlah cluster warna
kmeans = KMeans(n_clusters=k)
kmeans.fit(reshaped_image)

# Ekstrak warna dominan
dominant_colors = kmeans.cluster_centers_
dominant_colors = np.uint8(dominant_colors)

# Tampilkan warna dominan
plt.figure(figsize=(10, 5))
for i, color in enumerate(dominant_colors):
    plt.subplot(1, k, i + 1)
    plt.imshow([[color / 255]])  # Normalisasi ke rentang 0-1 untuk plt
    plt.axis('off')
    plt.title(f"Color {i+1}")
plt.show()

"""Hasil Analisis

Kode tersebut menggunakan K-Means Clustering untuk menentukan 5 warna dominan dalam gambar. Gambar diunggah, diubah ke format RGB, dan diratakan menjadi array piksel. Algoritma K-Means mengelompokkan piksel berdasarkan warna, lalu menghasilkan pusat cluster sebagai warna dominan. Warna dominan ditampilkan sebagai kotak warna dengan Matplotlib.
"""

from google.colab import files
import cv2
import matplotlib.pyplot as plt

# Unggah gambar
uploaded = files.upload()
filename = list(uploaded.keys())[0]

# Load gambar
image = cv2.imread(filename)
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Gaussian Blur untuk mengurangi noise
blurred = cv2.GaussianBlur(gray, (7, 7), 0)

# Adaptive Threshold untuk pencahayaan tidak merata
threshold = cv2.adaptiveThreshold(
    blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2
)

# Deteksi tepi menggunakan Canny
edges = cv2.Canny(threshold, 50, 150)

# Temukan kontur
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Filter kontur besar berdasarkan area
filtered_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > 500]  # Fokus pada objek besar

# Periksa apakah kontur ditemukan
if len(filtered_contours) > 0:
    # Gambar kontur pada gambar asli
    output = image.copy()
    cv2.drawContours(output, filtered_contours, -1, (0, 255, 0), 2)

    # Tampilkan hasil
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1), plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB)), plt.title("Original Image")
    plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(output, cv2.COLOR_BGR2RGB)), plt.title("Detected Contours")
    plt.show()
else:
    print("No contours detected. Try adjusting the threshold or area filter parameters.")

"""Hasil Analisis

Kode tersebut digunakan untuk mendeteksi dan menggambar kontur objek besar dalam gambar. Gambar diunggah, diubah ke grayscale, dan diproses dengan Gaussian Blur untuk mengurangi noise. Kemudian, adaptive thresholding digunakan untuk menangani pencahayaan yang tidak merata, dan deteksi tepi dilakukan menggunakan algoritma Canny.
Kontur ditemukan dengan cv2.findContours, lalu difilter berdasarkan area untuk fokus pada objek besar. Jika kontur terdeteksi, kontur tersebut digambar pada gambar asli dan hasilnya ditampilkan menggunakan Matplotlib. Jika tidak ada kontur yang terdeteksi, pesan saran untuk menyesuaikan parameter ditampilkan.
"""